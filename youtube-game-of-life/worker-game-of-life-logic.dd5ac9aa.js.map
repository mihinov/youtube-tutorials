{"mappings":"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","sources":["youtube-game-of-life/scripts/workers/worker-game-of-life-logic.js"],"sourcesContent":["class GameLifeLogic {\n\t#activeCells = 0;\n\t#random = false;\n\n\tget activeCells() {\n\t\treturn this.#activeCells;\n\t}\n\n\t/**\n\t * Хранит состояние поля в виде карты, где ключ - строка с координатами ячейки, значение - булево значение,\n\t * показывающее, жива ли ячейка\n\t * @type {Map<string, boolean>}\n\t */\n\t#field = new Map();\n\n\tget field() {\n\t\treturn this.#field;\n\t}\n\n\t/**\n\t * Хранит временное состояние поля в виде карты, где ключ - строка с координатами ячейки,\n\t * значение - булево значение, показывающее, жива ли ячейка\n\t * @type {Map<string, boolean>}\n\t */\n\t#buffer = new Map();\n\n\tget buffer() {\n\t\treturn this.#buffer;\n\t}\n\n\n\t#rows = 10;\n\t#cols = 10;\n\n\tget rows() {\n\t\treturn this.#rows;\n\t}\n\n\tget cols() {\n\t\treturn this.#cols;\n\t}\n\n\tconstructor() {\n\n\t}\n\n\t/**\n\t * Приватная функция\n\t * Создаёт поле с нуля\n\t * @param {boolean} random - рандомно генерировать элементы или нет\n\t * @returns {void}\n\t */\n\t#initFields(random) {\n\t\tthis.#field = new Map();\n\t\tthis.#buffer = new Map();\n\t\tthis.#activeCells = 0;\n\n\t\tfor (let i = 0; i < this.#rows; i++) {\n\t\t\tfor (let j = 0; j < this.#cols; j++) {\n\t\t\t\tconst key = this.#getKey(i, j);\n\t\t\t\tconst rndVal = Math.round(Math.random()) === 1;\n\t\t\t\tconst val = random === true ? rndVal : false;\n\t\t\t\tif (val === true) this.#activeCells++;\n\t\t\t\tthis.#field.set(key, val);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Публичная функция\n\t * Создаёт поле с нуля\n\t * @param {boolean} random - рандомно генерировать элементы или нет\n\t * @param {number} rows - количество строк поля\n\t * @param {number} cols - количество столбцов поля\n\t * @returns {void}\n\t */\n\tinitFields(random, rows, cols) {\n\t\tthis.#rows = rows;\n\t\tthis.#cols = cols;\n\t\tthis.#random = random;\n\n\t\tthis.#initFields(random);\n\n\t\treturn {\n\t\t\tcols: this.cols,\n\t\t\trows: this.rows,\n\t\t\tactiveCells: this.activeCells,\n\t\t\tfield: this.field,\n\t\t\tbuffer: this.buffer\n\t\t}\n\t}\n\n\t/**\n\t * Возвращает ключ в формате строки для определенной строки и столбца\n\t * @param {number} row - номер строки\n\t * @param {number} col - номер столбца\n\t * @returns {string} - ключ в формате строки\n\t */\n\t#getKey(row, col) {\n\t\treturn `${row}-${col}`;\n\t}\n\n\t/**\n\t * Возвращает количество соседей для определенной ячейки\n\t * @param {number} row - номер строки\n\t * @param {number} col - номер столбца\n\t * @returns {number} - количество соседей\n\t */\n\t#countNeighbours(row, col) {\n\t\tlet count = 0;\n\n\t\tfor (let i = -1; i <= 1; i++) {\n\t\t\tfor (let j = -1; j <= 1; j++) {\n\t\t\t\tif (i === 0 && j === 0) continue;\n\t\t\t\tconst r = row + i;\n\t\t\t\tconst c = col + j;\n\t\t\t\tconst key = this.#getKey(r, c);\n\t\t\t\tif (this.#field.get(key)) count++;\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n\t#updateField() {\n\t\tthis.#activeCells = 0;\n\t\tthis.#buffer = new Map();\n\n\t\tfor (let i = 0; i < this.#rows; i++) {\n\t\t\tfor (let j = 0; j < this.#cols; j++) {\n\t\t\t\tconst neighbours = this.#countNeighbours(i, j);\n\t\t\t\tconst key = this.#getKey(i, j);\n\n\t\t\t\tif (this.#field.get(key)) {\n\t\t\t\t\tif (neighbours < 2 || neighbours > 3) {\n\t\t\t\t\t\tthis.#buffer.set(key, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.#activeCells++;\n\t\t\t\t\t\tthis.#buffer.set(key, true);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (neighbours === 3) {\n\t\t\t\t\t\tthis.#activeCells++;\n\t\t\t\t\t\tthis.#buffer.set(key, true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.#buffer.set(key, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[this.#field, this.#buffer] = [this.#buffer, this.#field];\n\t}\n\n\tupdateField() {\n\t\tthis.#updateField();\n\n\t\treturn {\n\t\t\tcols: this.cols,\n\t\t\trows: this.rows,\n\t\t\tactiveCells: this.activeCells,\n\t\t\tfield: this.field,\n\t\t\tbuffer: this.buffer\n\t\t}\n\t}\n\n\t/**\n\t * Возвращает количество соседей для определенной ячейки\n\t * @param {'delete' | 'create'} typeAction - номер строки\n\t * @param {string} key - номер столбца\n\t */\n\tdeleteOrCreateCell(typeAction, key) {\n\t\tif (typeAction === 'delete') {\n\t\t\tthis.#activeCells--;\n\t\t\tthis.#field.set(key, false);\n\t\t} else if (typeAction === 'create') {\n\t\t\tthis.#activeCells++\n\t\t\tthis.#field.set(key, true);\n\t\t}\n\t}\n\n\t/**\n\t * Приватная функция\n\t * Изменяет размеры игрового поля\n\t * @param {number} newRows - количество строк\n\t * @param {number} newCols - количество стобцов\n\t */\n\t#resizeField(newRows, newCols) {\n\t\tif (newRows === this.#rows && newCols === this.#cols) return;\n\n\t\tconst oldField = this.#field;\n\t\tconst oldRows = this.#rows;\n\t\tconst oldCols = this.#cols;\n\n\t\tthis.#field = new Map();\n\t\tthis.#buffer = new Map();\n\t\tthis.#activeCells = 0;\n\n\t\tfor (let i = 0; i < newRows; i++) {\n\t\t\tfor (let j = 0; j < newCols; j++) {\n\t\t\t\tconst key = this.#getKey(i, j);\n\t\t\t\tconst val = oldField.get(key) || false;\n\t\t\t\tif (val === true) this.#activeCells++;\n\t\t\t\tthis.#field.set(key, val);\n\t\t\t}\n\t\t}\n\n\t\tif (newRows > oldRows || newCols > oldCols) {\n\t\t\tfor (let i = 0; i < newRows; i++) {\n\t\t\t\tfor (let j = 0; j < newCols; j++) {\n\t\t\t\t\tconst key = this.#getKey(i, j);\n\t\t\t\t\tif (!oldField.has(key)) {\n\t\t\t\t\t\tconst rndVal = Math.round(Math.random()) === 1;\n\t\t\t\t\t\tconst val = this.#random === true ? rndVal : false;\n\t\t\t\t\t\tif (val === true) this.#activeCells++;\n\t\t\t\t\t\tthis.#field.set(key, val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (newRows < oldRows || newCols < oldCols) {\n\t\t\tfor (let i = 0; i < newRows; i++) {\n\t\t\t\tfor (let j = 0; j < newCols; j++) {\n\t\t\t\t\tconst key = this.#getKey(i, j);\n\t\t\t\t\tconst val = !!oldField.get(key);\n\n\t\t\t\t\tif (val === true) this.#activeCells++;\n\n\t\t\t\t\tthis.#buffer.set(key, val);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.#field = this.#buffer;\n\t\t\tthis.#buffer = oldField;\n\t\t}\n\t}\n\n\t/**\n\t * Публичная функция\n\t * Изменяет размеры игрового поля\n\t * @param {number} newRows - количество строк\n\t * @param {number} newCols - количество стобцов\n\t * @param {boolean} random - рандомно генерировать ячейки или нет\n\t */\n\tresizeField(newRows, newCols, random) {\n\t\tthis.#random = random;\n\t\tthis.#rows = newRows;\n\t\tthis.#cols = newCols;\n\n\t\tthis.#resizeField(newRows, newCols);\n\n\t\treturn {\n\t\t\tcols: this.cols,\n\t\t\trows: this.rows,\n\t\t\tactiveCells: this.activeCells,\n\t\t\tfield: this.field,\n\t\t\tbuffer: this.buffer\n\t\t}\n\t}\n\n\n}\n\nconst gameOfLife = new GameLifeLogic();\n\nonmessage = function(event) {\n\tconst data = event.data;\n\tconst type = data.type;\n\tconst payload = data.payload;\n\n\tif (type === 'initFields') {\n\t\tconst dataToSend = gameOfLife.initFields(payload.random, payload.rows, payload.cols);\n\n\t\tpostMessage({\n\t\t\ttype: 'result: initFields',\n\t\t\tdata: dataToSend\n\t\t});\n\n\t} else if (type === 'updateField') {\n\t\tconst dataToSend = gameOfLife.updateField();\n\n\t\tpostMessage({\n\t\t\ttype: 'result: updateField',\n\t\t\tdata: dataToSend\n\t\t});\n\n\t} else if (type === 'deleteOrCreateCell') {\n\t\tconst dataToSend = gameOfLife.deleteOrCreateCell(payload.typeAction, payload.key);\n\n\t\tpostMessage({\n\t\t\ttype: 'result: deleteOrCreateCell',\n\t\t\tdata: dataToSend\n\t\t});\n\n\t} else if (type === 'resizeField') {\n\t\tconst dataToSend = gameOfLife.resizeField(payload.newRows, payload.newCols, payload.random);\n\n\t\tpostMessage({\n\t\t\ttype: 'result: resizeField',\n\t\t\tdata: dataToSend\n\t\t});\n\n\t}\n};\n"],"names":["GameLifeLogic","activeCells","random","this","field","Map","buffer","rows","cols","constructor","initFields","i","j","key","getKey","rndVal","Math","round","val","set","row","col","countNeighbours","row1","col1","count","r","c","get","updateField","neighbours","deleteOrCreateCell","typeAction","resizeField","newRows","newCols","oldField","oldRows","oldCols","has","gameOfLife","onmessage","event","data","type","payload","dataToSend","postMessage"],"version":3,"file":"worker-game-of-life-logic.dd5ac9aa.js.map"}