{"mappings":"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","sources":["<anon>","youtube-game-of-life/only-ts/scripts/workers/worker-game-of-life-logic.js"],"sourcesContent":["class GameLifeLogic {\n    #activeCells = 0;\n    #random = false;\n    get activeCells() {\n        return this.#activeCells;\n    }\n    /**\n\t * Хранит состояние поля в виде карты, где ключ - строка с координатами ячейки, значение - булево значение,\n\t * показывающее, жива ли ячейка\n\t * @type {Map<string, boolean>}\n\t */ #field = new Map();\n    get field() {\n        return this.#field;\n    }\n    /**\n\t * Хранит временное состояние поля в виде карты, где ключ - строка с координатами ячейки,\n\t * значение - булево значение, показывающее, жива ли ячейка\n\t * @type {Map<string, boolean>}\n\t */ #buffer = new Map();\n    get buffer() {\n        return this.#buffer;\n    }\n    #rows = 10;\n    #cols = 10;\n    get rows() {\n        return this.#rows;\n    }\n    get cols() {\n        return this.#cols;\n    }\n    constructor(){}\n    /**\n\t * Приватная функция\n\t * Создаёт поле с нуля\n\t * @param {boolean} random - рандомно генерировать элементы или нет\n\t * @returns {void}\n\t */ #initFields(random) {\n        this.#field = new Map();\n        this.#buffer = new Map();\n        this.#activeCells = 0;\n        for(let i = 0; i < this.#rows; i++)for(let j = 0; j < this.#cols; j++){\n            const key = this.#getKey(i, j);\n            const rndVal = Math.round(Math.random()) === 1;\n            const val = random === true ? rndVal : false;\n            if (val === true) this.#activeCells++;\n            this.#field.set(key, val);\n        }\n    }\n    /**\n\t * Публичная функция\n\t * Создаёт поле с нуля\n\t * @param {boolean} random - рандомно генерировать элементы или нет\n\t * @param {number} rows - количество строк поля\n\t * @param {number} cols - количество столбцов поля\n\t * @returns {void}\n\t */ initFields(random, rows, cols) {\n        this.#rows = rows;\n        this.#cols = cols;\n        this.#random = random;\n        this.#initFields(random);\n        return {\n            cols: this.cols,\n            rows: this.rows,\n            activeCells: this.activeCells,\n            field: this.field,\n            buffer: this.buffer\n        };\n    }\n    /**\n\t * Возвращает ключ в формате строки для определенной строки и столбца\n\t * @param {number} row - номер строки\n\t * @param {number} col - номер столбца\n\t * @returns {string} - ключ в формате строки\n\t */ #getKey(row, col) {\n        return `${row}-${col}`;\n    }\n    /**\n\t * Возвращает количество соседей для определенной ячейки\n\t * @param {number} i - номер строки\n\t * @param {number} j - номер столбца\n\t * @returns {number} - количество соседей\n\t */ #countNeighbours(i, j) {\n        let count = 0;\n        for(let x = -1; x <= 1; x++)for(let y = -1; y <= 1; y++){\n            if (x === 0 && y === 0) continue; // Пропустить текущую ячейку\n            const row = (i + x + this.#rows) % this.#rows; // Использование операции % для циклической границы\n            const col = (j + y + this.#cols) % this.#cols; // Использование операции % для циклической границы\n            const key = this.#getKey(row, col);\n            if (this.#field.get(key)) count++;\n        }\n        return count;\n    }\n    #updateField() {\n        this.#activeCells = 0;\n        this.#buffer = new Map();\n        for(let i = 0; i < this.#rows; i++)for(let j = 0; j < this.#cols; j++){\n            const neighbours = this.#countNeighbours(i, j);\n            const key = this.#getKey(i, j);\n            if (this.#field.get(key)) {\n                if (neighbours < 2 || neighbours > 3) this.#buffer.set(key, false);\n                else {\n                    this.#activeCells++;\n                    this.#buffer.set(key, true);\n                }\n            } else if (neighbours === 3) {\n                this.#activeCells++;\n                this.#buffer.set(key, true);\n            } else this.#buffer.set(key, false);\n        }\n        [this.#field, this.#buffer] = [\n            this.#buffer,\n            this.#field\n        ];\n    }\n    updateField() {\n        this.#updateField();\n        return {\n            cols: this.cols,\n            rows: this.rows,\n            activeCells: this.activeCells,\n            field: this.field,\n            buffer: this.buffer\n        };\n    }\n    /**\n\t * Возвращает количество соседей для определенной ячейки\n\t * @param {'delete' | 'create'} typeAction - номер строки\n\t * @param {string} key - номер столбца\n\t */ deleteOrCreateCell(typeAction, key) {\n        if (typeAction === \"delete\") {\n            this.#activeCells--;\n            this.#field.set(key, false);\n        } else if (typeAction === \"create\") {\n            this.#activeCells++;\n            this.#field.set(key, true);\n        }\n    }\n    /**\n\t * Приватная функция\n\t * Изменяет размеры игрового поля\n\t * @param {number} newRows - количество строк\n\t * @param {number} newCols - количество стобцов\n\t * @param {boolean} random - рандомно генерировать ячейки или нет\n\t */ #resizeField(newRows, newCols, random) {\n        if (newRows === this.#rows && newCols === this.#cols) return;\n        const oldField = this.#field;\n        const oldRows = this.#rows;\n        const oldCols = this.#cols;\n        this.#random = random;\n        this.#rows = newRows;\n        this.#cols = newCols;\n        this.#field = new Map();\n        this.#buffer = new Map();\n        this.#activeCells = 0;\n        for(let i = 0; i < newRows; i++)for(let j = 0; j < newCols; j++){\n            const key = this.#getKey(i, j);\n            const val = oldField.get(key) || false;\n            if (val === true) this.#activeCells++;\n            this.#field.set(key, val);\n        }\n        if (newRows > oldRows || newCols > oldCols) {\n            for(let i = 0; i < newRows; i++)for(let j = 0; j < newCols; j++){\n                const key = this.#getKey(i, j);\n                if (!oldField.has(key)) {\n                    const rndVal = Math.round(Math.random()) === 1;\n                    const val = this.#random === true ? rndVal : false;\n                    if (val === true) this.#activeCells++;\n                    this.#field.set(key, val);\n                }\n            }\n        }\n        if (newRows < oldRows || newCols < oldCols) {\n            for(let i = 0; i < newRows; i++)for(let j = 0; j < newCols; j++){\n                const key = this.#getKey(i, j);\n                const val = !!oldField.get(key);\n                if (val === true) this.#activeCells++;\n                this.#buffer.set(key, val);\n            }\n            this.#field = this.#buffer;\n            this.#buffer = oldField;\n        }\n    }\n    /**\n\t * Публичная функция\n\t * Изменяет размеры игрового поля\n\t * @param {number} newRows - количество строк\n\t * @param {number} newCols - количество стобцов\n\t * @param {boolean} random - рандомно генерировать ячейки или нет\n\t */ resizeField(newRows, newCols, random) {\n        this.#resizeField(newRows, newCols, random);\n        return {\n            cols: this.cols,\n            rows: this.rows,\n            activeCells: this.activeCells,\n            field: this.field,\n            buffer: this.buffer\n        };\n    }\n}\nconst gameOfLife = new GameLifeLogic();\nonmessage = function(event) {\n    const data = event.data;\n    const type = data.type;\n    const payload = data.payload;\n    if (type === \"initFields\") {\n        const dataToSend = gameOfLife.initFields(payload.random, payload.rows, payload.cols);\n        postMessage({\n            type: \"result: initFields\",\n            data: dataToSend\n        });\n    } else if (type === \"updateField\") {\n        const dataToSend = gameOfLife.updateField();\n        postMessage({\n            type: \"result: updateField\",\n            data: dataToSend\n        });\n    } else if (type === \"deleteOrCreateCell\") {\n        const dataToSend = gameOfLife.deleteOrCreateCell(payload.typeAction, payload.key);\n        postMessage({\n            type: \"result: deleteOrCreateCell\",\n            data: dataToSend\n        });\n    } else if (type === \"resizeField\") {\n        const dataToSend = gameOfLife.resizeField(payload.newRows, payload.newCols, payload.random);\n        postMessage({\n            type: \"result: resizeField\",\n            data: dataToSend\n        });\n    }\n};\n\n//# sourceMappingURL=worker-game-of-life-logic.60d3cd9a.js.map\n","class GameLifeLogic {\n\t#activeCells = 0;\n\t#random = false;\n\n\tget activeCells() {\n\t\treturn this.#activeCells;\n\t}\n\n\t/**\n\t * Хранит состояние поля в виде карты, где ключ - строка с координатами ячейки, значение - булево значение,\n\t * показывающее, жива ли ячейка\n\t * @type {Map<string, boolean>}\n\t */\n\t#field = new Map();\n\n\tget field() {\n\t\treturn this.#field;\n\t}\n\n\t/**\n\t * Хранит временное состояние поля в виде карты, где ключ - строка с координатами ячейки,\n\t * значение - булево значение, показывающее, жива ли ячейка\n\t * @type {Map<string, boolean>}\n\t */\n\t#buffer = new Map();\n\n\tget buffer() {\n\t\treturn this.#buffer;\n\t}\n\n\n\t#rows = 10;\n\t#cols = 10;\n\n\tget rows() {\n\t\treturn this.#rows;\n\t}\n\n\tget cols() {\n\t\treturn this.#cols;\n\t}\n\n\tconstructor() {\n\n\t}\n\n\t/**\n\t * Приватная функция\n\t * Создаёт поле с нуля\n\t * @param {boolean} random - рандомно генерировать элементы или нет\n\t * @returns {void}\n\t */\n\t#initFields(random) {\n\t\tthis.#field = new Map();\n\t\tthis.#buffer = new Map();\n\t\tthis.#activeCells = 0;\n\n\t\tfor (let i = 0; i < this.#rows; i++) {\n\t\t\tfor (let j = 0; j < this.#cols; j++) {\n\t\t\t\tconst key = this.#getKey(i, j);\n\t\t\t\tconst rndVal = Math.round(Math.random()) === 1;\n\t\t\t\tconst val = random === true ? rndVal : false;\n\t\t\t\tif (val === true) this.#activeCells++;\n\t\t\t\tthis.#field.set(key, val);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Публичная функция\n\t * Создаёт поле с нуля\n\t * @param {boolean} random - рандомно генерировать элементы или нет\n\t * @param {number} rows - количество строк поля\n\t * @param {number} cols - количество столбцов поля\n\t * @returns {void}\n\t */\n\tinitFields(random, rows, cols) {\n\t\tthis.#rows = rows;\n\t\tthis.#cols = cols;\n\t\tthis.#random = random;\n\n\t\tthis.#initFields(random);\n\n\t\treturn {\n\t\t\tcols: this.cols,\n\t\t\trows: this.rows,\n\t\t\tactiveCells: this.activeCells,\n\t\t\tfield: this.field,\n\t\t\tbuffer: this.buffer\n\t\t}\n\t}\n\n\t/**\n\t * Возвращает ключ в формате строки для определенной строки и столбца\n\t * @param {number} row - номер строки\n\t * @param {number} col - номер столбца\n\t * @returns {string} - ключ в формате строки\n\t */\n\t#getKey(row, col) {\n\t\treturn `${row}-${col}`;\n\t}\n\n\t/**\n\t * Возвращает количество соседей для определенной ячейки\n\t * @param {number} i - номер строки\n\t * @param {number} j - номер столбца\n\t * @returns {number} - количество соседей\n\t */\n\t#countNeighbours(i, j) {\n\t\tlet count = 0;\n\n\t\tfor (let x = -1; x <= 1; x++) {\n\t\t\tfor (let y = -1; y <= 1; y++) {\n\t\t\t\tif (x === 0 && y === 0) continue; // Пропустить текущую ячейку\n\t\t\t\tconst row = (i + x + this.#rows) % this.#rows; // Использование операции % для циклической границы\n\t\t\t\tconst col = (j + y + this.#cols) % this.#cols; // Использование операции % для циклической границы\n\t\t\t\tconst key = this.#getKey(row, col);\n\n\t\t\t\tif (this.#field.get(key)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n\t#updateField() {\n\t\tthis.#activeCells = 0;\n\t\tthis.#buffer = new Map();\n\n\t\tfor (let i = 0; i < this.#rows; i++) {\n\t\t\tfor (let j = 0; j < this.#cols; j++) {\n\t\t\t\tconst neighbours = this.#countNeighbours(i, j);\n\t\t\t\tconst key = this.#getKey(i, j);\n\n\t\t\t\tif (this.#field.get(key)) {\n\t\t\t\t\tif (neighbours < 2 || neighbours > 3) {\n\t\t\t\t\t\tthis.#buffer.set(key, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.#activeCells++;\n\t\t\t\t\t\tthis.#buffer.set(key, true);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (neighbours === 3) {\n\t\t\t\t\t\tthis.#activeCells++;\n\t\t\t\t\t\tthis.#buffer.set(key, true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.#buffer.set(key, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[this.#field, this.#buffer] = [this.#buffer, this.#field];\n\t}\n\n\tupdateField() {\n\t\tthis.#updateField();\n\n\t\treturn {\n\t\t\tcols: this.cols,\n\t\t\trows: this.rows,\n\t\t\tactiveCells: this.activeCells,\n\t\t\tfield: this.field,\n\t\t\tbuffer: this.buffer\n\t\t}\n\t}\n\n\t/**\n\t * Возвращает количество соседей для определенной ячейки\n\t * @param {'delete' | 'create'} typeAction - номер строки\n\t * @param {string} key - номер столбца\n\t */\n\tdeleteOrCreateCell(typeAction, key) {\n\t\tif (typeAction === 'delete') {\n\t\t\tthis.#activeCells--;\n\t\t\tthis.#field.set(key, false);\n\t\t} else if (typeAction === 'create') {\n\t\t\tthis.#activeCells++\n\t\t\tthis.#field.set(key, true);\n\t\t}\n\t}\n\n\t/**\n\t * Приватная функция\n\t * Изменяет размеры игрового поля\n\t * @param {number} newRows - количество строк\n\t * @param {number} newCols - количество стобцов\n\t * @param {boolean} random - рандомно генерировать ячейки или нет\n\t */\n\t#resizeField(newRows, newCols, random) {\n\t\tif (newRows === this.#rows && newCols === this.#cols) return;\n\n\t\tconst oldField = this.#field;\n\t\tconst oldRows = this.#rows;\n\t\tconst oldCols = this.#cols;\n\n\t\tthis.#random = random;\n\t\tthis.#rows = newRows;\n\t\tthis.#cols = newCols;\n\t\tthis.#field = new Map();\n\t\tthis.#buffer = new Map();\n\t\tthis.#activeCells = 0;\n\n\t\tfor (let i = 0; i < newRows; i++) {\n\t\t\tfor (let j = 0; j < newCols; j++) {\n\t\t\t\tconst key = this.#getKey(i, j);\n\t\t\t\tconst val = oldField.get(key) || false;\n\t\t\t\tif (val === true) this.#activeCells++;\n\t\t\t\tthis.#field.set(key, val);\n\t\t\t}\n\t\t}\n\n\t\tif (newRows > oldRows || newCols > oldCols) {\n\t\t\tfor (let i = 0; i < newRows; i++) {\n\t\t\t\tfor (let j = 0; j < newCols; j++) {\n\t\t\t\t\tconst key = this.#getKey(i, j);\n\t\t\t\t\tif (!oldField.has(key)) {\n\t\t\t\t\t\tconst rndVal = Math.round(Math.random()) === 1;\n\t\t\t\t\t\tconst val = this.#random === true ? rndVal : false;\n\t\t\t\t\t\tif (val === true) this.#activeCells++;\n\t\t\t\t\t\tthis.#field.set(key, val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (newRows < oldRows || newCols < oldCols) {\n\t\t\tfor (let i = 0; i < newRows; i++) {\n\t\t\t\tfor (let j = 0; j < newCols; j++) {\n\t\t\t\t\tconst key = this.#getKey(i, j);\n\t\t\t\t\tconst val = !!oldField.get(key);\n\n\t\t\t\t\tif (val === true) this.#activeCells++;\n\n\t\t\t\t\tthis.#buffer.set(key, val);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.#field = this.#buffer;\n\t\t\tthis.#buffer = oldField;\n\t\t}\n\t}\n\n\t/**\n\t * Публичная функция\n\t * Изменяет размеры игрового поля\n\t * @param {number} newRows - количество строк\n\t * @param {number} newCols - количество стобцов\n\t * @param {boolean} random - рандомно генерировать ячейки или нет\n\t */\n\tresizeField(newRows, newCols, random) {\n\t\tthis.#resizeField(newRows, newCols, random);\n\n\t\treturn {\n\t\t\tcols: this.cols,\n\t\t\trows: this.rows,\n\t\t\tactiveCells: this.activeCells,\n\t\t\tfield: this.field,\n\t\t\tbuffer: this.buffer\n\t\t}\n\t}\n\n\n}\n\nconst gameOfLife = new GameLifeLogic();\n\nonmessage = function (event) {\n\tconst data = event.data;\n\tconst type = data.type;\n\tconst payload = data.payload;\n\n\tif (type === 'initFields') {\n\t\tconst dataToSend = gameOfLife.initFields(payload.random, payload.rows, payload.cols);\n\n\t\tpostMessage({\n\t\t\ttype: 'result: initFields',\n\t\t\tdata: dataToSend\n\t\t});\n\n\t} else if (type === 'updateField') {\n\t\tconst dataToSend = gameOfLife.updateField();\n\n\t\tpostMessage({\n\t\t\ttype: 'result: updateField',\n\t\t\tdata: dataToSend\n\t\t});\n\n\t} else if (type === 'deleteOrCreateCell') {\n\t\tconst dataToSend = gameOfLife.deleteOrCreateCell(payload.typeAction, payload.key);\n\n\t\tpostMessage({\n\t\t\ttype: 'result: deleteOrCreateCell',\n\t\t\tdata: dataToSend\n\t\t});\n\n\t} else if (type === 'resizeField') {\n\t\tconst dataToSend = gameOfLife.resizeField(payload.newRows, payload.newCols, payload.random);\n\n\t\tpostMessage({\n\t\t\ttype: 'result: resizeField',\n\t\t\tdata: dataToSend\n\t\t});\n\n\t}\n};\n"],"names":["GameLifeLogic","activeCells","random","field","Map","buffer","rows","cols","constructor","initFields","i","j","key","getKey","rndVal","Math","round","val","set","row","col","countNeighbours","count","x","y","get","updateField","neighbours","deleteOrCreateCell","typeAction","resizeField","newRows","newCols","oldField","oldRows","oldCols","has","gameOfLife","onmessage","event","data","type","payload","dataToSend","postMessage"],"version":3,"file":"worker-game-of-life-logic.60d3cd9a.js.map"}