{"mappings":"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","sources":["<anon>","youtube-game-of-life/only-ts/scripts/workers/worker-game-of-life-logic.js"],"sourcesContent":["class GameLifeLogic {\n    #activeCells = 0;\n    #random = false;\n    get activeCells() {\n        return this.#activeCells;\n    }\n    /**\r\n\t * Хранит состояние поля в виде карты, где ключ - строка с координатами ячейки, значение - булево значение,\r\n\t * показывающее, жива ли ячейка\r\n\t * @type {Map<string, boolean>}\r\n\t */ #field = new Map();\n    get field() {\n        return this.#field;\n    }\n    /**\r\n\t * Хранит временное состояние поля в виде карты, где ключ - строка с координатами ячейки,\r\n\t * значение - булево значение, показывающее, жива ли ячейка\r\n\t * @type {Map<string, boolean>}\r\n\t */ #buffer = new Map();\n    get buffer() {\n        return this.#buffer;\n    }\n    #rows = 10;\n    #cols = 10;\n    get rows() {\n        return this.#rows;\n    }\n    get cols() {\n        return this.#cols;\n    }\n    constructor(){}\n    /**\r\n\t * Приватная функция\r\n\t * Создаёт поле с нуля\r\n\t * @param {boolean} random - рандомно генерировать элементы или нет\r\n\t * @returns {void}\r\n\t */ #initFields(random) {\n        this.#field = new Map();\n        this.#buffer = new Map();\n        this.#activeCells = 0;\n        for(let i = 0; i < this.#rows; i++)for(let j = 0; j < this.#cols; j++){\n            const key = this.#getKey(i, j);\n            const rndVal = Math.round(Math.random()) === 1;\n            const val = random === true ? rndVal : false;\n            if (val === true) this.#activeCells++;\n            this.#field.set(key, val);\n        }\n    }\n    /**\r\n\t * Публичная функция\r\n\t * Создаёт поле с нуля\r\n\t * @param {boolean} random - рандомно генерировать элементы или нет\r\n\t * @param {number} rows - количество строк поля\r\n\t * @param {number} cols - количество столбцов поля\r\n\t * @returns {void}\r\n\t */ initFields(random, rows, cols) {\n        this.#rows = rows;\n        this.#cols = cols;\n        this.#random = random;\n        this.#initFields(random);\n        return {\n            cols: this.cols,\n            rows: this.rows,\n            activeCells: this.activeCells,\n            field: this.field,\n            buffer: this.buffer\n        };\n    }\n    /**\r\n\t * Возвращает ключ в формате строки для определенной строки и столбца\r\n\t * @param {number} row - номер строки\r\n\t * @param {number} col - номер столбца\r\n\t * @returns {string} - ключ в формате строки\r\n\t */ #getKey(row, col) {\n        return `${row}-${col}`;\n    }\n    /**\r\n\t * Возвращает количество соседей для определенной ячейки\r\n\t * @param {number} i - номер строки\r\n\t * @param {number} j - номер столбца\r\n\t * @returns {number} - количество соседей\r\n\t */ #countNeighbours(i, j) {\n        let count = 0;\n        for(let x = -1; x <= 1; x++)for(let y = -1; y <= 1; y++){\n            if (x === 0 && y === 0) continue; // Пропустить текущую ячейку\n            const row = (i + x + this.#rows) % this.#rows; // Использование операции % для циклической границы\n            const col = (j + y + this.#cols) % this.#cols; // Использование операции % для циклической границы\n            const key = this.#getKey(row, col);\n            if (this.#field.get(key)) count++;\n        }\n        return count;\n    }\n    #updateField() {\n        this.#activeCells = 0;\n        this.#buffer = new Map();\n        for(let i = 0; i < this.#rows; i++)for(let j = 0; j < this.#cols; j++){\n            const neighbours = this.#countNeighbours(i, j);\n            const key = this.#getKey(i, j);\n            if (this.#field.get(key)) {\n                if (neighbours < 2 || neighbours > 3) this.#buffer.set(key, false);\n                else {\n                    this.#activeCells++;\n                    this.#buffer.set(key, true);\n                }\n            } else if (neighbours === 3) {\n                this.#activeCells++;\n                this.#buffer.set(key, true);\n            } else this.#buffer.set(key, false);\n        }\n        [this.#field, this.#buffer] = [\n            this.#buffer,\n            this.#field\n        ];\n    }\n    updateField() {\n        this.#updateField();\n        return {\n            cols: this.cols,\n            rows: this.rows,\n            activeCells: this.activeCells,\n            field: this.field,\n            buffer: this.buffer\n        };\n    }\n    /**\r\n\t * Возвращает количество соседей для определенной ячейки\r\n\t * @param {'delete' | 'create'} typeAction - номер строки\r\n\t * @param {string} key - номер столбца\r\n\t */ deleteOrCreateCell(typeAction, key) {\n        if (typeAction === 'delete') {\n            this.#activeCells--;\n            this.#field.set(key, false);\n        } else if (typeAction === 'create') {\n            this.#activeCells++;\n            this.#field.set(key, true);\n        }\n    }\n    /**\r\n\t * Приватная функция\r\n\t * Изменяет размеры игрового поля\r\n\t * @param {number} newRows - количество строк\r\n\t * @param {number} newCols - количество стобцов\r\n\t * @param {boolean} random - рандомно генерировать ячейки или нет\r\n\t */ #resizeField(newRows, newCols, random) {\n        if (newRows === this.#rows && newCols === this.#cols) return;\n        const oldField = this.#field;\n        const oldRows = this.#rows;\n        const oldCols = this.#cols;\n        this.#random = random;\n        this.#rows = newRows;\n        this.#cols = newCols;\n        this.#field = new Map();\n        this.#buffer = new Map();\n        this.#activeCells = 0;\n        for(let i = 0; i < newRows; i++)for(let j = 0; j < newCols; j++){\n            const key = this.#getKey(i, j);\n            const val = oldField.get(key) || false;\n            if (val === true) this.#activeCells++;\n            this.#field.set(key, val);\n        }\n        if (newRows > oldRows || newCols > oldCols) {\n            for(let i = 0; i < newRows; i++)for(let j = 0; j < newCols; j++){\n                const key = this.#getKey(i, j);\n                if (!oldField.has(key)) {\n                    const rndVal = Math.round(Math.random()) === 1;\n                    const val = this.#random === true ? rndVal : false;\n                    if (val === true) this.#activeCells++;\n                    this.#field.set(key, val);\n                }\n            }\n        }\n        if (newRows < oldRows || newCols < oldCols) {\n            for(let i = 0; i < newRows; i++)for(let j = 0; j < newCols; j++){\n                const key = this.#getKey(i, j);\n                const val = !!oldField.get(key);\n                if (val === true) this.#activeCells++;\n                this.#buffer.set(key, val);\n            }\n            this.#field = this.#buffer;\n            this.#buffer = oldField;\n        }\n    }\n    /**\r\n\t * Публичная функция\r\n\t * Изменяет размеры игрового поля\r\n\t * @param {number} newRows - количество строк\r\n\t * @param {number} newCols - количество стобцов\r\n\t * @param {boolean} random - рандомно генерировать ячейки или нет\r\n\t */ resizeField(newRows, newCols, random) {\n        this.#resizeField(newRows, newCols, random);\n        return {\n            cols: this.cols,\n            rows: this.rows,\n            activeCells: this.activeCells,\n            field: this.field,\n            buffer: this.buffer\n        };\n    }\n}\nconst gameOfLife = new GameLifeLogic();\nonmessage = function(event) {\n    const data = event.data;\n    const type = data.type;\n    const payload = data.payload;\n    if (type === 'initFields') {\n        const dataToSend = gameOfLife.initFields(payload.random, payload.rows, payload.cols);\n        postMessage({\n            type: 'result: initFields',\n            data: dataToSend\n        });\n    } else if (type === 'updateField') {\n        const dataToSend = gameOfLife.updateField();\n        postMessage({\n            type: 'result: updateField',\n            data: dataToSend\n        });\n    } else if (type === 'deleteOrCreateCell') {\n        const dataToSend = gameOfLife.deleteOrCreateCell(payload.typeAction, payload.key);\n        postMessage({\n            type: 'result: deleteOrCreateCell',\n            data: dataToSend\n        });\n    } else if (type === 'resizeField') {\n        const dataToSend = gameOfLife.resizeField(payload.newRows, payload.newCols, payload.random);\n        postMessage({\n            type: 'result: resizeField',\n            data: dataToSend\n        });\n    }\n};\n\n//# sourceMappingURL=worker-game-of-life-logic.46d3668d.js.map\n","class GameLifeLogic {\r\n\t#activeCells = 0;\r\n\t#random = false;\r\n\r\n\tget activeCells() {\r\n\t\treturn this.#activeCells;\r\n\t}\r\n\r\n\t/**\r\n\t * Хранит состояние поля в виде карты, где ключ - строка с координатами ячейки, значение - булево значение,\r\n\t * показывающее, жива ли ячейка\r\n\t * @type {Map<string, boolean>}\r\n\t */\r\n\t#field = new Map();\r\n\r\n\tget field() {\r\n\t\treturn this.#field;\r\n\t}\r\n\r\n\t/**\r\n\t * Хранит временное состояние поля в виде карты, где ключ - строка с координатами ячейки,\r\n\t * значение - булево значение, показывающее, жива ли ячейка\r\n\t * @type {Map<string, boolean>}\r\n\t */\r\n\t#buffer = new Map();\r\n\r\n\tget buffer() {\r\n\t\treturn this.#buffer;\r\n\t}\r\n\r\n\r\n\t#rows = 10;\r\n\t#cols = 10;\r\n\r\n\tget rows() {\r\n\t\treturn this.#rows;\r\n\t}\r\n\r\n\tget cols() {\r\n\t\treturn this.#cols;\r\n\t}\r\n\r\n\tconstructor() {\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Приватная функция\r\n\t * Создаёт поле с нуля\r\n\t * @param {boolean} random - рандомно генерировать элементы или нет\r\n\t * @returns {void}\r\n\t */\r\n\t#initFields(random) {\r\n\t\tthis.#field = new Map();\r\n\t\tthis.#buffer = new Map();\r\n\t\tthis.#activeCells = 0;\r\n\r\n\t\tfor (let i = 0; i < this.#rows; i++) {\r\n\t\t\tfor (let j = 0; j < this.#cols; j++) {\r\n\t\t\t\tconst key = this.#getKey(i, j);\r\n\t\t\t\tconst rndVal = Math.round(Math.random()) === 1;\r\n\t\t\t\tconst val = random === true ? rndVal : false;\r\n\t\t\t\tif (val === true) this.#activeCells++;\r\n\t\t\t\tthis.#field.set(key, val);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Публичная функция\r\n\t * Создаёт поле с нуля\r\n\t * @param {boolean} random - рандомно генерировать элементы или нет\r\n\t * @param {number} rows - количество строк поля\r\n\t * @param {number} cols - количество столбцов поля\r\n\t * @returns {void}\r\n\t */\r\n\tinitFields(random, rows, cols) {\r\n\t\tthis.#rows = rows;\r\n\t\tthis.#cols = cols;\r\n\t\tthis.#random = random;\r\n\r\n\t\tthis.#initFields(random);\r\n\r\n\t\treturn {\r\n\t\t\tcols: this.cols,\r\n\t\t\trows: this.rows,\r\n\t\t\tactiveCells: this.activeCells,\r\n\t\t\tfield: this.field,\r\n\t\t\tbuffer: this.buffer\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Возвращает ключ в формате строки для определенной строки и столбца\r\n\t * @param {number} row - номер строки\r\n\t * @param {number} col - номер столбца\r\n\t * @returns {string} - ключ в формате строки\r\n\t */\r\n\t#getKey(row, col) {\r\n\t\treturn `${row}-${col}`;\r\n\t}\r\n\r\n\t/**\r\n\t * Возвращает количество соседей для определенной ячейки\r\n\t * @param {number} i - номер строки\r\n\t * @param {number} j - номер столбца\r\n\t * @returns {number} - количество соседей\r\n\t */\r\n\t#countNeighbours(i, j) {\r\n\t\tlet count = 0;\r\n\r\n\t\tfor (let x = -1; x <= 1; x++) {\r\n\t\t\tfor (let y = -1; y <= 1; y++) {\r\n\t\t\t\tif (x === 0 && y === 0) continue; // Пропустить текущую ячейку\r\n\t\t\t\tconst row = (i + x + this.#rows) % this.#rows; // Использование операции % для циклической границы\r\n\t\t\t\tconst col = (j + y + this.#cols) % this.#cols; // Использование операции % для циклической границы\r\n\t\t\t\tconst key = this.#getKey(row, col);\r\n\r\n\t\t\t\tif (this.#field.get(key)) {\r\n\t\t\t\t\tcount++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn count;\r\n\t}\r\n\r\n\t#updateField() {\r\n\t\tthis.#activeCells = 0;\r\n\t\tthis.#buffer = new Map();\r\n\r\n\t\tfor (let i = 0; i < this.#rows; i++) {\r\n\t\t\tfor (let j = 0; j < this.#cols; j++) {\r\n\t\t\t\tconst neighbours = this.#countNeighbours(i, j);\r\n\t\t\t\tconst key = this.#getKey(i, j);\r\n\r\n\t\t\t\tif (this.#field.get(key)) {\r\n\t\t\t\t\tif (neighbours < 2 || neighbours > 3) {\r\n\t\t\t\t\t\tthis.#buffer.set(key, false);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.#activeCells++;\r\n\t\t\t\t\t\tthis.#buffer.set(key, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (neighbours === 3) {\r\n\t\t\t\t\t\tthis.#activeCells++;\r\n\t\t\t\t\t\tthis.#buffer.set(key, true);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.#buffer.set(key, false);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t[this.#field, this.#buffer] = [this.#buffer, this.#field];\r\n\t}\r\n\r\n\tupdateField() {\r\n\t\tthis.#updateField();\r\n\r\n\t\treturn {\r\n\t\t\tcols: this.cols,\r\n\t\t\trows: this.rows,\r\n\t\t\tactiveCells: this.activeCells,\r\n\t\t\tfield: this.field,\r\n\t\t\tbuffer: this.buffer\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Возвращает количество соседей для определенной ячейки\r\n\t * @param {'delete' | 'create'} typeAction - номер строки\r\n\t * @param {string} key - номер столбца\r\n\t */\r\n\tdeleteOrCreateCell(typeAction, key) {\r\n\t\tif (typeAction === 'delete') {\r\n\t\t\tthis.#activeCells--;\r\n\t\t\tthis.#field.set(key, false);\r\n\t\t} else if (typeAction === 'create') {\r\n\t\t\tthis.#activeCells++\r\n\t\t\tthis.#field.set(key, true);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Приватная функция\r\n\t * Изменяет размеры игрового поля\r\n\t * @param {number} newRows - количество строк\r\n\t * @param {number} newCols - количество стобцов\r\n\t * @param {boolean} random - рандомно генерировать ячейки или нет\r\n\t */\r\n\t#resizeField(newRows, newCols, random) {\r\n\t\tif (newRows === this.#rows && newCols === this.#cols) return;\r\n\r\n\t\tconst oldField = this.#field;\r\n\t\tconst oldRows = this.#rows;\r\n\t\tconst oldCols = this.#cols;\r\n\r\n\t\tthis.#random = random;\r\n\t\tthis.#rows = newRows;\r\n\t\tthis.#cols = newCols;\r\n\t\tthis.#field = new Map();\r\n\t\tthis.#buffer = new Map();\r\n\t\tthis.#activeCells = 0;\r\n\r\n\t\tfor (let i = 0; i < newRows; i++) {\r\n\t\t\tfor (let j = 0; j < newCols; j++) {\r\n\t\t\t\tconst key = this.#getKey(i, j);\r\n\t\t\t\tconst val = oldField.get(key) || false;\r\n\t\t\t\tif (val === true) this.#activeCells++;\r\n\t\t\t\tthis.#field.set(key, val);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (newRows > oldRows || newCols > oldCols) {\r\n\t\t\tfor (let i = 0; i < newRows; i++) {\r\n\t\t\t\tfor (let j = 0; j < newCols; j++) {\r\n\t\t\t\t\tconst key = this.#getKey(i, j);\r\n\t\t\t\t\tif (!oldField.has(key)) {\r\n\t\t\t\t\t\tconst rndVal = Math.round(Math.random()) === 1;\r\n\t\t\t\t\t\tconst val = this.#random === true ? rndVal : false;\r\n\t\t\t\t\t\tif (val === true) this.#activeCells++;\r\n\t\t\t\t\t\tthis.#field.set(key, val);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (newRows < oldRows || newCols < oldCols) {\r\n\t\t\tfor (let i = 0; i < newRows; i++) {\r\n\t\t\t\tfor (let j = 0; j < newCols; j++) {\r\n\t\t\t\t\tconst key = this.#getKey(i, j);\r\n\t\t\t\t\tconst val = !!oldField.get(key);\r\n\r\n\t\t\t\t\tif (val === true) this.#activeCells++;\r\n\r\n\t\t\t\t\tthis.#buffer.set(key, val);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.#field = this.#buffer;\r\n\t\t\tthis.#buffer = oldField;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Публичная функция\r\n\t * Изменяет размеры игрового поля\r\n\t * @param {number} newRows - количество строк\r\n\t * @param {number} newCols - количество стобцов\r\n\t * @param {boolean} random - рандомно генерировать ячейки или нет\r\n\t */\r\n\tresizeField(newRows, newCols, random) {\r\n\t\tthis.#resizeField(newRows, newCols, random);\r\n\r\n\t\treturn {\r\n\t\t\tcols: this.cols,\r\n\t\t\trows: this.rows,\r\n\t\t\tactiveCells: this.activeCells,\r\n\t\t\tfield: this.field,\r\n\t\t\tbuffer: this.buffer\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\nconst gameOfLife = new GameLifeLogic();\r\n\r\nonmessage = function (event) {\r\n\tconst data = event.data;\r\n\tconst type = data.type;\r\n\tconst payload = data.payload;\r\n\r\n\tif (type === 'initFields') {\r\n\t\tconst dataToSend = gameOfLife.initFields(payload.random, payload.rows, payload.cols);\r\n\r\n\t\tpostMessage({\r\n\t\t\ttype: 'result: initFields',\r\n\t\t\tdata: dataToSend\r\n\t\t});\r\n\r\n\t} else if (type === 'updateField') {\r\n\t\tconst dataToSend = gameOfLife.updateField();\r\n\r\n\t\tpostMessage({\r\n\t\t\ttype: 'result: updateField',\r\n\t\t\tdata: dataToSend\r\n\t\t});\r\n\r\n\t} else if (type === 'deleteOrCreateCell') {\r\n\t\tconst dataToSend = gameOfLife.deleteOrCreateCell(payload.typeAction, payload.key);\r\n\r\n\t\tpostMessage({\r\n\t\t\ttype: 'result: deleteOrCreateCell',\r\n\t\t\tdata: dataToSend\r\n\t\t});\r\n\r\n\t} else if (type === 'resizeField') {\r\n\t\tconst dataToSend = gameOfLife.resizeField(payload.newRows, payload.newCols, payload.random);\r\n\r\n\t\tpostMessage({\r\n\t\t\ttype: 'result: resizeField',\r\n\t\t\tdata: dataToSend\r\n\t\t});\r\n\r\n\t}\r\n};\r\n"],"names":["GameLifeLogic","activeCells","Map","field","buffer","rows","cols","constructor","random","i","j","key","rndVal","Math","round","val","set","initFields","row","col","count","x","y","get","neighbours","updateField","deleteOrCreateCell","typeAction","newRows","newCols","oldField","oldRows","oldCols","has","resizeField","gameOfLife","onmessage","event","data","type","payload","postMessage"],"version":3,"file":"worker-game-of-life-logic.46d3668d.js.map"}